<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Architecture | Sohan's Blog]]></title>
  <link href="http://smsohan.com/blog/categories/architecture/atom.xml" rel="self"/>
  <link href="http://smsohan.com/"/>
  <updated>2021-01-01T11:41:23-07:00</updated>
  <id>http://smsohan.com/</id>
  <author>
    <name><![CDATA[SM Sohan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Software Architecture - Topic 2: People]]></title>
    <link href="http://smsohan.com/blog/2020/12/30/software-architecture-part-2-people/"/>
    <updated>2020-12-30T21:03:00-07:00</updated>
    <id>http://smsohan.com/blog/2020/12/30/software-architecture-part-2-people</id>
    <content type="html"><![CDATA[<p>To be an architect, you'll have to be a leader. And, to be a leader, you'll have to be able to understand people and create an influence on them. So, focusing on the people involved with a system is a pre-requisite for designing systems that delight them.</p>

<p><img src="/images/DaleCarnegieBook.png" alt="How To Win Friends And Influence People" /></p>

<p><small>Photo credits to <a href="https://flic.kr/p/N7J52S">Alan O'Rourke</a></small></p>

<p>For this topic, I want you to read and internaize the ideas from the book <a href="https://www.amazon.com/How-Win-Friends-Influence-People/dp/0671027034/ref=sr_1_1?dchild=1&amp;keywords=Dale+Carnegie&amp;qid=1609523629&amp;s=books&amp;sr=1-1">How to Win Fiends and Influence People</a> by Dale Carnegie. Honestly, it's a fun read for anyone, not just for the aspiring architect. But an architect must be able to listen with empathy and clearly share her ideas. She needs to truly appreciate diverse opinion because it's common that a delightful system can be designed in many ways, and she's likely to have her blindspots. Moreover, she needs exceptional conflict-resolution skills to create a safe space so the best ideas win irrespective of where it comes from.</p>

<p>I know some of you may be getting impatient because you want to learn hardcore software architecture and I'm not talking anything technical yet. If you can hold your patience and bear with me, we'll get there soon enough. I have what I think an exciting curriculum where I'll be teaching hardcore software design topics using many well-known open-source products. My goal is to set you up for success as an architect, and these softcore topics are of the highest proirity in my curriculum. The small number of great architects I've enjoyed working with have won me over by their people skills. All the other architects may have been technically genius, but lacked people skills to appreciate the essence of a delightful system.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Software Architecture - Topic 1: Delightfulness]]></title>
    <link href="http://smsohan.com/blog/2020/12/26/software-artchitecture-part-1/"/>
    <updated>2020-12-26T15:07:00-07:00</updated>
    <id>http://smsohan.com/blog/2020/12/26/software-artchitecture-part-1</id>
    <content type="html"><![CDATA[<p><em>"I want to be an architect"</em> - is a common career goal I hear during one:one meetings and annual reviews with my team members. Honestly, I'm writing this series of blog posts to bring some clarity and structure into my own thoughts, and hopefully to scale my time. You can even say, I'm open-sourcing my mentorship on the topic of software archtecture. My sincere hope is, this series helps my team or anyone who wants to systematically learn and improve their software design skills.</p>

<p>My mental model of a software architect as a system is as follows:</p>

<pre>
                 _________
                |         |
Requirements -> |         |
                |         |
 Environment -> |Architect| -> "Delightful" System Design
                |         |
      People -> |         |
                |_________|
</pre>


<p>That is, they produce the most delightful system design as the output from three inputs: business requirements, the environment that surrounds the system, and the people that are involved with the system. The main phrase to remember is <strong>"the most delightful"</strong> - because this is what makes the architect's job so much fun and appealing.</p>

<p>First, I recommend reading the book <a href="https://www.amazon.com/Design-Everyday-Things-Revised-Expanded/dp/0465050654">The Design of Everyday Things</a> to learn how design impacts us everyday. It's a fun and must read for anyone involved in any kind of design.</p>

<p>Next, I recommend reading the book <a href="https://www.amazon.com/Dont-Make-Think-Revisited-Usability/dp/0321965515/ref=sr_1_1?crid=EH17W0BAL06D&amp;dchild=1&amp;keywords=don%27t+make+me+think&amp;qid=1609281299&amp;s=books&amp;sprefix=don%27t+make+%2Cstripbooks-intl-ship%2C200&amp;sr=1-1">Don't Make Me Think</a> to learn about how to know if your design is delightful.</p>

<p>I prefer the word delightfulness over usability or customer obsession because the former sets a high bar. I hope you also internalize the goal of designing the most delightful systems and settle for nothing less, why should you?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Tribute to Time Travel APIs in Ruby on Rails]]></title>
    <link href="http://smsohan.com/blog/2020/12/07/tribute-to-rails-date-time-great-invisible-design/"/>
    <updated>2020-12-07T10:28:00-07:00</updated>
    <id>http://smsohan.com/blog/2020/12/07/tribute-to-rails-date-time-great-invisible-design</id>
    <content type="html"><![CDATA[<blockquote><p>Good design is obvious. Great design is transparent. â€” Joe Sparano</p></blockquote>

<p>Ruby on Rails delighted me all through my career. The community is one with a taste for art, thanks to DHH's ability to write well. He set a  high bar and the community also lives up to it. One API that absolutely blows my mind is how delightful it is to work with date and time in Ruby on Rails. Here are a few example use cases:</p>

<p>```ruby</p>

<h1>Schedule a report to run at the beginning of next week</h1>

<p>report.run_at = 1.week.from_now.beginning_of_week</p>

<h1>.. or first Friday of next month</h1>

<p>report.run_at = report.run_at.next_occurring(:friday) unless report.run_at.friday?</p>

<h1>.. or beginning of next month</h1>

<p>report.run_at = 1.month.from_now.beginning_of_month</p>

<h1>.. or mid-day tomorrow</h1>

<p>report.run_at = 1.day.from_now.at_midday</p>

<h1>Is today a weekday?</h1>

<p>Time.now.on_weekday?</p>

<h1>.. or a weekend?</h1>

<p>Time.now.on_weekend?</p>

<h1>Book a calendar event for a whole day</h1>

<p>time_off.duration = Time.now.all_day</p>

<h1>.. or find sales in the current quarter</h1>

<p>Sale.where(created_at: Time.now.all_quarter)...
```</p>

<p>A lot of time related code I've seen in real projects is finding a point in time relative to <code>now</code>. Ruby on Rails makes it an absolute joy traveling time by adding time related methods straight into the <a href="https://api.rubyonrails.org">Integer</a> class, where the code looks just like how we think about time. Sure, Rails uses complex classes such as <code>TimeWithZone</code>, <code>Duration</code>, etc. under the hood, but I've almost never seen those used directly. This is such a stark contrast with many other platforms where you have to use pedantic concepts such as <code>TimeSpan</code>, <code>Calendar</code>, <code>GregorianCalendar</code>, etc. The true elegance of time travel API in Ruby on Rails lies in how invisible it is.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How About Full-Stack Micro-Services?]]></title>
    <link href="http://smsohan.com/blog/2019/11/17/how-about-full-stack-micro-services/"/>
    <updated>2019-11-17T13:47:00-07:00</updated>
    <id>http://smsohan.com/blog/2019/11/17/how-about-full-stack-micro-services</id>
    <content type="html"><![CDATA[<p><img src="/images/patched_quilt.jpg" alt="patched quilt" /></p>

<p><small>
Source: <a href="https://flic.kr/p/pUW8f9">Audrey on Flickr</a>
</small></p>

<p>I think nobody knows how to stitch together an app with full-stack micro-services. I have the following open-questions if you disagree. Of course, if we could send people to moon, we could solve these problems. But the question is, is it worth and should your team  solve these problems? Especially, for small teams?</p>

<ol>
<li>How to render the UI from tens of independent micro-services into the same web page?</li>
<li>How to ensure the JS and CSS libraries are compatible within all of the independent services?</li>
<li>How to aggregate logs from the services to be able to trace a user / request / transaction?</li>
<li>How to measure and reduce overall latency and spinner-fatigue?</li>
<li>Which off-the-shelf framework can be used for achieving the above?</li>
</ol>


<p>Headless micro-services are easy to build, but in many ways are similar to integration over database. It helps scaling teams, but even if you have many teams, I'd say extract service where it makes sense instead of adopting that model as the default choice.</p>

<p>I suggest being careful about following conference talks and blogs on how cool micro-services are. It may work for big and gig tech. They don't always turn a profit! Your small teams are more likely to drown in worthless complexity from a micro-service architecture.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Software Architecture is all about Ugly Boxes and Lines - My Wishlist]]></title>
    <link href="http://smsohan.com/blog/2019/08/10/software-architecture-is-all-aboout-ugly-boxes-and-lines/"/>
    <updated>2019-08-10T20:28:00-06:00</updated>
    <id>http://smsohan.com/blog/2019/08/10/software-architecture-is-all-aboout-ugly-boxes-and-lines</id>
    <content type="html"><![CDATA[<p>In my last post, I claimed <a href="/blog/2019/08/02/all-talk-no-show-software-architecture/">software architecture is all talk and no show</a>. When we have a visible one, it's a bunch of poorly drawn boxes and lines. I don't have a problem with boxes or lines, but I do like beautiful drawings.</p>

<p>Despite many standards, we still mostly use  whiteboard drawing of boxes and lines for sharing software design as we build new systems or introduce new team members. Where it sucks is the lack of evolution and context of the rest of the system that's not drawn on the board.</p>

<p>A digital repro of software architecture diagrams often happen in PowerPoint or similar tools that allow us to draw boxes and lines. This process is so rough that people just give up.</p>

<p>At work, I have been using <a href="http://www.websequencediagrams.com">WebSequenceDiagram</a>. While it's still not an eye-candy, I like the fact that you can draw a diagram from using plain text. Consider this as an input to create the accompanying diagram:</p>

<p><code>
title Toilet Flush System
User -&gt; Flush Lever: Push
Flush Lever -&gt; Outlet Valve: Open
Outlet Valve -&gt; Toilet Bowl: Water
Outlet Valve -&gt; Inlet Valve: Open
</code></p>

<p><img src="/images/Toilet_Flush_System.png" alt="Sequence Diagram" /></p>

<p>While this text to sequence diagram is a great achievement for a tool, I don't see such tools for software architecture diagrams. Here's my wishlist of features that I'd want in a software architecture tool:</p>

<ol>
<li><strong>Text input</strong>. Allows us to easily create the diagrams and use all the version control features.</li>
<li><strong>Map like UX</strong>: Allows us to easily transition between higher and lower level components.</li>
<li><strong>Beautiful</strong>.</li>
</ol>


<p>Do you know any? Do these requirements make sense?</p>
]]></content>
  </entry>
  
</feed>
