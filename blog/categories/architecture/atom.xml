<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Architecture | Sohan's Blog]]></title>
  <link href="http://smsohan.com/blog/categories/architecture/atom.xml" rel="self"/>
  <link href="http://smsohan.com/"/>
  <updated>2020-11-18T11:25:24-07:00</updated>
  <id>http://smsohan.com/</id>
  <author>
    <name><![CDATA[SM Sohan]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How About Full-Stack Micro-Services?]]></title>
    <link href="http://smsohan.com/blog/2019/11/17/how-about-full-stack-micro-services/"/>
    <updated>2019-11-17T13:47:00-07:00</updated>
    <id>http://smsohan.com/blog/2019/11/17/how-about-full-stack-micro-services</id>
    <content type="html"><![CDATA[<p><img src="/images/patched_quilt.jpg" alt="patched quilt" /></p>

<p><small>
Source: <a href="https://flic.kr/p/pUW8f9">Audrey on Flickr</a>
</small></p>

<p>I think nobody knows how to stitch together an app with full-stack micro-services. I have the following open-questions if you disagree. Of course, if we could send people to moon, we could solve these problems. But the question is, is it worth and should your team  solve these problems? Especially, for small teams?</p>

<ol>
<li>How to render the UI from tens of independent micro-services into the same web page?</li>
<li>How to ensure the JS and CSS libraries are compatible within all of the independent services?</li>
<li>How to aggregate logs from the services to be able to trace a user / request / transaction?</li>
<li>How to measure and reduce overall latency and spinner-fatigue?</li>
<li>Which off-the-shelf framework can be used for achieving the above?</li>
</ol>


<p>Headless micro-services are easy to build, but in many ways are similar to integration over database. It helps scaling teams, but even if you have many teams, I'd say extract service where it makes sense instead of adopting that model as the default choice.</p>

<p>I suggest being careful about following conference talks and blogs on how cool micro-services are. It may work for big and gig tech. They don't always turn a profit! Your small teams are more likely to drown in worthless complexity from a micro-service architecture.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Software Architecture is all about Ugly Boxes and Lines - My Wishlist]]></title>
    <link href="http://smsohan.com/blog/2019/08/10/software-architecture-is-all-aboout-ugly-boxes-and-lines/"/>
    <updated>2019-08-10T20:28:00-06:00</updated>
    <id>http://smsohan.com/blog/2019/08/10/software-architecture-is-all-aboout-ugly-boxes-and-lines</id>
    <content type="html"><![CDATA[<p>In my last post, I claimed <a href="/blog/2019/08/02/all-talk-no-show-software-architecture/">software architecture is all talk and no show</a>. When we have a visible one, it's a bunch of poorly drawn boxes and lines. I don't have a problem with boxes or lines, but I do like beautiful drawings.</p>

<p>Despite many standards, we still mostly use  whiteboard drawing of boxes and lines for sharing software design as we build new systems or introduce new team members. Where it sucks is the lack of evolution and context of the rest of the system that's not drawn on the board.</p>

<p>A digital repro of software architecture diagrams often happen in PowerPoint or similar tools that allow us to draw boxes and lines. This process is so rough that people just give up.</p>

<p>At work, I have been using <a href="http://www.websequencediagrams.com">WebSequenceDiagram</a>. While it's still not an eye-candy, I like the fact that you can draw a diagram from using plain text. Consider this as an input to create the accompanying diagram:</p>

<p><code>
title Toilet Flush System
User -&gt; Flush Lever: Push
Flush Lever -&gt; Outlet Valve: Open
Outlet Valve -&gt; Toilet Bowl: Water
Outlet Valve -&gt; Inlet Valve: Open
</code></p>

<p><img src="/images/Toilet_Flush_System.png" alt="Sequence Diagram" /></p>

<p>While this text to sequence diagram is a great achievement for a tool, I don't see such tools for software architecture diagrams. Here's my wishlist of features that I'd want in a software architecture tool:</p>

<ol>
<li><strong>Text input</strong>. Allows us to easily create the diagrams and use all the version control features.</li>
<li><strong>Map like UX</strong>: Allows us to easily transition between higher and lower level components.</li>
<li><strong>Beautiful</strong>.</li>
</ol>


<p>Do you know any? Do these requirements make sense?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[All Talk No Show: Software Architecture]]></title>
    <link href="http://smsohan.com/blog/2019/08/02/all-talk-no-show-software-architecture/"/>
    <updated>2019-08-02T08:46:00-06:00</updated>
    <id>http://smsohan.com/blog/2019/08/02/all-talk-no-show-software-architecture</id>
    <content type="html"><![CDATA[<p>We have a problem with software architecture. Let's face it. Find the architecture diagrams of the products you're working on and answer these questions:</p>

<ol>
<li>Did you find it?</li>
<li>Does everyone in your team know where to find it?</li>
<li>Is it up-to-date?</li>
<li>Can you see how this system scales, handles failover, monitors performance, or how it's secured?</li>
<li>Can you see how it evolved over time?</li>
<li>Can you train a new team-member using this diagram?</li>
</ol>


<p>This is the first micro-post of a series of such as I aim to build a compelling case for fundamentally changing software architecture diagrams.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On Keeping Things Simple]]></title>
    <link href="http://smsohan.com/blog/2014/09/25/on-keeping-things-simple/"/>
    <updated>2014-09-25T08:28:00-06:00</updated>
    <id>http://smsohan.com/blog/2014/09/25/on-keeping-things-simple</id>
    <content type="html"><![CDATA[<p>Software architecture, or any design for that matter, needs to strike a fine balance between simplicity and power. Sometimes, the design needs to deliberately remove elements that'd make life better in some way but also cause a lot of frictions in other ways, ways that may not really impact the designer.</p>

<p>A few examples to explain this. Client side MVC frameworks on top of a server side MVC framework. Client side URL routing on top of server side URL routing. Persisting data in many different databases.</p>

<p>All these examples have one common theme: they offer some value in exchange of additional complexity, often time the complexity grows with time as future developments happen, eventually costing more than the value gained.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monolith vs Microservices]]></title>
    <link href="http://smsohan.com/blog/2014/09/18/monolith-vs-micro-services/"/>
    <updated>2014-09-18T14:56:00-06:00</updated>
    <id>http://smsohan.com/blog/2014/09/18/monolith-vs-micro-services</id>
    <content type="html"><![CDATA[<p>Microservices are talk of the town these days. I wanted to share my thoughts on microservices based on some experiments that we are running into at our current project.</p>

<p><img src="/images/minions.jpg" alt="minons" /></p>

<p>SOURCE: <a href="https://www.flickr.com/photos/31366276@N03/9327275207/in/photostream/">https://www.flickr.com/photos/31366276@N03/9327275207/in/photostream/</a></p>

<p>Recently, we deployed a microservice for two-step verification feature on one of our projects. This was a strict business requirement, because having a separate server to store your 2nd-factor authorization provides additional security in case the servers hosting your primary factor are compromised.</p>

<p>We operate on a cloud environment, so spinning up new servers is a simple process. The source code for this whole Ruby on Rails based two-step verification service is no more than a couple hundred lines. So, in theory, it should be very easy to deploy such a service. However, it proved to be a lot of work in the end.</p>

<p>For example, to deploy this service, we actually had to spin <strong>a few servers</strong> for each of our staging and production environments. They also had to be <strong>load balanced</strong> for obvious reasons. They needed their <strong>own database</strong> for the business requirements, which also needed automated <strong>periodic backups</strong>. <strong>Networking and VPN</strong> related configurations as well as <strong>DNS</strong> configurations were also required. <strong>Monitoring</strong> tools had to be configured so we can get alerts in case things were about to fail. <strong>Deployment scripts</strong> had to be written for this service as well.</p>

<blockquote><p>All in all, I'd say <strong>it took 20x the time to deploy this microservice than writing the code for it</strong>.</p></blockquote>

<p>Really. No kidding.</p>

<p>Since it has been deployed, we didn't ship changes as often to this service compared to our main project. This is what I find to be the primary benefit of this approach, since it doesn't require as big a regression test during our releases.</p>

<p>However, when things go wrong, our debug efforts are harder since more infrastructural pieces are involved. Considering the additional work required and the value gain, I'm really not sure if microservices provide any real ROI.</p>

<p>The additional complexity of dealing with many servers as opposed to a larger app may or may not be worth it. I agree with Martin Fowler on the <a href="http://martinfowler.com/bliki/MicroservicePrerequisites.html">prerequisites of microservices</a>. Unless, you have streamlined an automated way to provision new servers with all required parts, it may actually be best for you to keep working on the monolith. It's not the end of the world, and you'll have more time to spend with the family!</p>
]]></content>
  </entry>
  
</feed>
