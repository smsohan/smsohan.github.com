---
layout: post
title: "ActionMailer 3 - why do you call instance methods as class/self methods?"
date: 2011-01-28
comments: false
categories:
 - Ruby
 - Architecture
 - Rails
---

<div class='post'>
I didn't even notice this little trick! As long as I didn't have to call deliver_welcome_message (or deliver_*) methods that would magically call welcome_message, I was happy that now the magic is gone. Things are transparent!<br />Here's an example showing the change: Say you have the following mailer:<br /><pre class="ruby">class Notifier &lt; ActionMailer::Base<br />  def welcome_message(new_user)<br />    #a warm welcome message<br />  end<br />end</pre>Now, prior to Rails 3, or ActionMailer 3, you would write the following to actually call this method to get the benefits of ActionMailer magics, such as finding the view based on method name and so on:<br /><pre class="ruby">Notifier.deliver_welcome_message(new_user_instance)  </pre>I am sure this deliver_* was a clever design decision to solve a hard problem, that is, finding the view name based on the method name. However, in ActionMailer 3, this is gone. Now the question is, if this trick is gone, how come it still finds the view name from the method name? Who sets the view name? To know the answer, first, let's take a look at how we call the welcome_message now.<br /><pre class="ruby">Notifier.welcome_message(new_user_instance).send</pre><pre class="ruby">Instead of</pre><br /><pre class="ruby" style="margin-bottom: 0px; margin-left: 0px; margin-right: 0px; margin-top: 0px;">Notifier.<b>new</b>.welcome_message(new_user_instance).send</pre><br />So, the magic deliver_ prefix is gone. But, did you see the new trick? Well, its a clever design again. The trick this time is, you call your instance method, welcome_message as if it was a class method. But there is no class method called welcome_message, so it instead goes to method_missing and thats how it sets up the view name from this call. Here's the code that does this little trick!<br /><pre class="ruby">def method_missing(method, *args) #:nodoc:<br />    return super unless respond_to?(method)<br />    new(method, *args).message<br />  end</pre>All it does is, instantiates the mailer with the method name!<br /><br />However, this design decision has interesting side effects as well. Or may be not side effects, but rather core effects. For example, since you are calling your mailer methods as class methods, you cannot use a single mailer instance to send out multiple emails at the same time. In fact, every mailer has only one instance of message. So, it cannot store two messages at the same time. This is as if, you can have multiple methods in a class, but you cannot call more than one class or you will mess up the class's state!<br /><br />Wonder why? Well, this is rooted in another key design choice: ActionMailer::Base is a subclass of AbstractController::Base. Now, if you look at controllers, you will notice that at any given point of time, a controller instance is only responsible for responding to a single action. This is logical for controllers. But how about mailers? I see a mismatch in my mental model and the actual implementation model. I don't see a reason why a mailer is a controller! For the sake of code reuse? But that could be done via delegation anyway.<br /><br />I will end this post with one question: <br /><b><span class="Apple-style-span" style="color: #073763;">Do you think mailer is a controller?</span></b> hints: think about LSP.</div>
